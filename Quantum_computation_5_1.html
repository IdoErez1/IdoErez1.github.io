
<!DOCTYPE html>
<html data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    
        <link rel="stylesheet" href='./styles/main_style.css'>
        <script type="text/javascript" src="./scripts/dark_mode.js" ></script>
        <link rel="stylesheet" href='./styles/style.css'>
        <script>
window.MathJax = {
  tex: {
    inlineMath: [["$", "$"], ["\\(", "\\)"]],
    displayMath: [["$$", "$$"], ["\[", "\]"]],
    processEscapes: true,
    packages: ['base', 'ams', 'cancel', 'braket', 'mathtools', 'boldsymbol']
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process',
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }

  },
  loader: {
    load: ['[tex]/cancel', '[tex]/braket', '[tex]/mathtools', '[tex]/boldsymbol']
  }
};
window.onload = () => {
    const urlParams = new URLSearchParams(window.location.search);
    // Get the value of the 'item' parameter
    const item = urlParams.get('item'); 
    keywords = document.getElementsByClassName("keyword"); 
    for(let i = 0; i< keywords.length; i++){
    if(item==keywords[i].innerText){
    keywords[i].scrollIntoView();}} 

    const divs = document.querySelectorAll('div.content > div'); //:has(span):has(p)
    console.log(divs);
    divs.forEach(div => {
        div.addEventListener('mouseup', (event) => {
            // Check if it's middle button (button 1)
            console.log(div);
            if (event.button === 1) {
                console.log('Middle click detected');
                            // Get both paragraphs and lists
            const paragraphs = div.getElementsByTagName('p');
            const lists = div.querySelectorAll('ul, ol'); // Get both unordered and ordered lists
            
            console.log(paragraphs);
            console.log(lists);
            
            // Toggle each paragraph's visibility
            Array.from(paragraphs).forEach(paragraph => {
                if (paragraph.classList.contains('paragraph-hidden')) {
                    // Show paragraph
                    paragraph.classList.remove('paragraph-hidden');
                    // Update max-height to match content
                    paragraph.style.maxHeight = paragraph.scrollHeight + 'px';
                    console.log('Showing paragraph');
                } else {
                    // Hide paragraph
                    paragraph.classList.add('paragraph-hidden');
                    console.log('Hiding paragraph');
                }
            });
            
            // Toggle each list's visibility
            Array.from(lists).forEach(list => {
                if (list.classList.contains('paragraph-hidden')) {
                    // Show list (using the same class for consistency)
                    list.classList.remove('paragraph-hidden');
                    // Update max-height to match content
                    list.style.maxHeight = list.scrollHeight + 'px';
                    console.log('Showing list');
                } else {
                    // Hide list
                    list.classList.add('paragraph-hidden');
                    console.log('Hiding list');
                }
            });
                // Prevent default middle-click behavior
                event.preventDefault();
                return false;
            }
        });

        // Prevent the default middle-click scrolling behavior
        div.addEventListener('mousedown', (event) => {
            if (event.button === 1) {
                event.preventDefault();
                return false;
            }
        });
    });

};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"></script>    <script type='text/javascript' src='./scripts/main_script.js'></script>
            <title>שערים קוונטים</title>
        </head>
        <body>
        <ul class='top-navigation'>
<li class='next-page'><a href='./Quantum_computation_5_2.html'>5.2 מעגלים קוונטים</a></li>
<li class='parent-page'><a href='./Quantum_computation.html'> חישוב קוונטי</a><ul class='parent-dropdown'>
<li class='parent-page-dropdown'><div class='dropdown-div'>1. יסודות</div><ul class='parent-dropdown-dropdown'>
<li class='parent_page-dropdown'><a href='./Quantum_computation_1_1.html'>1.1 עקרונות הפיזיקה הקוונטית</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_1_2.html'>1.2 ספינים וסיבובים</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_1_3.html'>1.3 מטריצת צפיפות וצברים</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_1_4.html'>1.4 שזירה</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>2. מערכות פתוחות</div><ul class='parent-dropdown-dropdown'>
<li class='parent_page-dropdown'><a href='./Quantum_computation_2_1.html'>2.1 מדידה אורתוגונאלית</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_2_2.html'>2.2 מדידה מוכללת</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_2_3.html'>2.3 ערוצים קוונטים</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_2_4.html'>2.4 שלושה ערוצי קיוביט</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_2_5.html'>2.5 משוואת המאסטר</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>3. שזירה</div><ul class='parent-dropdown-dropdown'>
<li class='parent_page-dropdown'><a href='./Quantum_computation_3_1.html'>3.1 מצבי בל</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_3_2.html'>3.2 שימושים של שזירה</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>4. מעגלים קלאסיים</div><ul class='parent-dropdown-dropdown'>
<li class='parent_page-dropdown'><a href='./Quantum_computation_4_1.html'>4.1 חישוב</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_4_2.html'>4.2 מחלקות סיבוכיות</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_4_3.html'>4.3 מעגלים הפיכים</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>5. מעגלים קוונטים</div><ul class='parent-dropdown-dropdown'>
<li class='parent_page-dropdown'><a href='./Quantum_computation_5_1.html'>5.1 שערים קוונטים</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_5_2.html'>5.2 מעגלים קוונטים</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_5_3.html'>5.3 אוניברסליות של מעגלים קוונטים</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_5_4.html'>5.4 קבצות שערים אוניברסליים</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>6. מימוש פיזי של מחשב קוונטי</div><ul class='parent-dropdown-dropdown'>
<li class='parent_page-dropdown'><a href='./Quantum_computation_6_1.html'>6.1 מלכודת פאול - קלאסי</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_6_2.html'>6.2 מלכודת פאול - קוונטי</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>7. אלגוריתמים קוונטים</div><ul class='parent-dropdown-dropdown'>
<li class='parent_page-dropdown'><a href='./Quantum_computation_7_1.html'>7.1 בעיות קבועה-מאוזנת</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_7_2.html'>7.2 מחזוריות</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_7_3.html'>7.3 התמרת פורייה קוונטית</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_7_4.html'>7.4 חיפוש</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>8. סימולציה קוונטית והצפנה</div><ul class='parent-dropdown-dropdown'>
<li class='parent_page-dropdown'><a href='./Quantum_computation_8_1.html'>8.1 טרוטריזציה</a></li>
<li class='parent_page-dropdown'><a href='./Quantum_computation_8_2.html'>8.2 תיקון שגיאות - קוד שור</a></li>
</ul></li>
</ul></li>
<li class='prev-page'><a href='./Quantum_computation_4_3.html'>4.3 מעגלים הפיכים</a></li>
</ul></li><script>document.addEventListener('keydown', function(event){if (event.key === 'ArrowRight') {window.location.href = `./Quantum_computation_5_2.html`;}if (event.key === 'ArrowLeft'){window.location.href = `./Quantum_computation_4_3.html`;}});</script>
        <div class="content">
        <h1>5.1  שערים קוונטים</h1>
    <p>נרצה לבנות מודל מתמטי של מעגלים קוונטים באופן דומה לאיך שבנינו את המודל המתמטי של מעגלים קלאסים.</p>
<div class="proposition"><span class="keyword">שער קוונטי</span><p>זה המקביל של שער קלאסי. במקום לבצע אבל פעולה בינארית יפעיל למשעשה אופרטור אוניטרי שפועל על מספר קבוע של קיוביטים. </p>
</div>
<div class="definition"><span class="keyword">דרישות של מחשב קוונטי</span><ol>
<li>
<p>המרחב ההילברט יהיה מרחב מכפלה של מרחבי קיוביט. </p>
</li>
<li>
<p>ניתן לאפס אותו. כלומר ניתן להביאו למצב <span>\(\ket{000\dots 0}\)</span>. דרך לעשות את זה למשל זה לקרר לטמפרטורות קרובות ל-0 המוחלט. </p>
</li>
<li>
<p>כמות השערים הקוונטים הם סופיים. </p>
</li>
<li>
<p>המעגל נבנה ומנוהל על ידי מחשב קלאסי. </p>
</li>
<li>
<p>קל לקריאה בבסיס החישובי(computational basis), אשר ניתן למדד בסוף התהליך. </p>
</li>
</ol>
</div>
<div class="remark">
<p>ניתן לקיים את המודל הזה עם מחשב קלאסי, אבל יהיה לא יעיל. וכן המקרה הקוונטי יהיה הכללה של המקרה הקלאסי(כי הרי ניתן להגביל את האופרטורים האוניטרים לאופרטורי תמורה).</p>
</div>
<div class="definition"><span class="keyword">מחלקת P</span><p>משפחת מעגלים אשר גדל לכל היותר באיזשהי חזקה של גודל הקלט <span>\(n\)</span>.</p>
</div>
<div class="definition"><span class="keyword">מחלקת NP</span><p>כל המשפחות מעגלים אשר ניתן לוודא את הפיתרון שלהם בזמן פולינומיאלי.</p>
</div>
<div class="definition"><span class="keyword">מחלקת BPP</span><p>כל המשפחות מעגלים עם קצב גידול היסתברותי חסום על ידי פולינום.</p>
</div>
<div class="definition"><span class="keyword">מחלקת MA</span><p>כל המשפחות מעגלים אשר ניתן לוודא את הפיתרון שלהם בצורה הסתברותית בזמן פולינומיאלי.</p>
</div>
<div class="definition"><span class="keyword">מחלקת BQP</span><p>כל המשפחות מעגלים קוונטים עם קצב גידול היסתברותי פולינומיאלי(מקביל ל-BPP).</p>
</div>
<div class="definition"><span class="keyword">מחלקת QMA</span><p>כל המשפחות המעגלים הקוונטים אשר ניתן לוודא את הפתרון בזמן פולינומיאלי(מקביל ל-MA).</p>
</div>
<div class="proposition">
<p><span>$$\mathsf{P}\subseteq{\mathsf{BPP}}\subseteq{\mathsf{BQP}}\subseteq{\mathsf{QMA}}.$$</span></p>
</div>
<div class="proposition">
<p><span>$${\mathsf{P}}\subseteq{\mathsf{N P}}\subseteq{\mathsf{M A}}\subseteq{\mathsf{Q M A}}$$</span></p>
</div>
<div class="definition"><span class="keyword">שער הדמאר</span><p><span>$$H:|x\rangle\to\frac{1}{\sqrt{2}}\sum_{y}(-1)^{x y}|y\rangle$$</span>
כלומר:
<span>$$\ket{0} \mapsto \frac{1}{\sqrt{ 2 }}\left( \ket{0} +\ket{1}  \right)\qquad \ket{1} \mapsto \frac{1}{\sqrt{ 2 }}\left( \ket{0} -\ket{1}  \right)$$</span>
כאשר המטריצה האונטירית המתאמיה ל-<span>\(H\)</span> תהיה:
<span>$$H:\left(\begin{array}{c  c}{{\frac{1}{\sqrt{2}}}}&amp;{{\frac{1}{\sqrt{2}}}}\\ {{\frac{1}{\sqrt{2}}}}&amp;{{-\frac{1}{\sqrt{2}}}}\end{array}\right)$$</span></p>
</div>
<div class="definition"><span class="keyword">control ו-target</span><p>שער בו רכיב אחד נקרא ה-control והרכיב השני נקרא ה-target. כאשר ה-control מקבל <span>\(\ket{0}\)</span> אז מבצע את האופרטור <span>\(U\)</span>, אחרת לא עושה כלום. מפורשות ניתן לכתוב:
<span>$$\Lambda (U)=\ket{0} \bra{0} \otimes \mathbb{1} +\ket{1} \bra{1} \otimes U $$</span></p>
</div>
<div class="proposition">
<p>ניתן לכתוב אופרטור נשלט על ידי:
<span>$$\Lambda\left(U\right)=P_{A}\otimes\left|0_{u}\right\rangle\left\langle0_{u}\right|_{B}+Q_{A}\otimes\left|1_{u}\right\rangle\left\langle1_{u}\right|_{B}$$</span>
כאשר
<span>$$P=\left|0\right\rangle\left\langle0\right|+e^{i\phi_{0}}\left|1\right\rangle\left\langle1\right|\qquad Q=\left|0\right\rangle\left\langle0\right|+e^{i\phi_{1}}\left|1\right\rangle\left\langle1\right|$$</span></p>
</div>
<div class="proof">
<p>אנו יודעים כי:
<span>$$\Lambda\left(U\right)=\left|0\right\rangle\left\langle0\right|_{A}\otimes\mathbb{1}_{B}+\left|1\right\rangle\left\langle1\right|_{A}\otimes U_{B}$$</span>
כיוון ש-<span>\(U\)</span> אוניטרי קיים בסיס אשר מלכסן אותו, ולכן ניתן לכתוב:
<span>$$U=e^{i\phi_{0}}\left|0_{u}\right\rangle\left\langle0_{u}\right|+e^{i\phi_{1}}\left|1_{u}\right\rangle\left\langle1_{u}\right|$$</span>
כאשר אם נציב את <span>\(U\)</span> בתוך ה controlled <span>\(U\)</span> כאשר נכתוב את היחידה במפורש נקבל:
<span>$$\Lambda\left(U\right)=\left|0\right\rangle\left\langle0\right|_{A}\otimes\left[\left|0_{u}\right\rangle\left\langle0_{u}\right|+\left|1_{u}\right\rangle\left\langle1_{u}\right|\right]_{B}+\left|1\right\rangle\left\langle1\right|_{A}\otimes\left[e^{i\phi_{0}}\left|0_{u}\right\rangle\left\langle0_{u}\right|+e^{i\phi_{1}}\left|1_{u}\right\rangle\left\langle1_{u}\right|\right]_{B}$$</span>
אם נאחד את ההטלות על <span>\(B\)</span> נקבל:
<span>$$\Lambda\left(U\right)=\underbrace{ \left[\left|0\right\rangle\left\langle0\right|+e^{i\phi_{0}}\left|1\right\rangle\left\langle1\right|\right]_{A} }_{ P }\otimes\left|0_{u}\right\rangle\left\langle0_{u}\right|_{B}+\underbrace{ \left[\left|0\right\rangle\left\langle0\right|+e^{i\phi_{1}}\left|1\right\rangle\left\langle1\right|\right]_{A} }_{ Q }\otimes\left|1_{u}\right\rangle\left\langle1_{u}\right|_{B}$$</span></p>
</div>
<div class="corollary">
<p>עבור <span>\(P=\mathbb{1}\)</span> ניתן לחשוב על זה בתור אופרטור על <span>\(A\)</span> אשר נשלט על ידי <span>\(B\)</span>.</p>
</div>
<div class="corollary">
<p>ניתן כעת לעבור לבסיס החישובי על ידי מעבר בסיס כלומר על ידי הפעלת אופרטור <span>\(W\)</span> אשר מקיים:
<span>$$W|0_{u}\rangle=\left|0\right\rangle \qquad W|1_{u}\rangle=|1\rangle$$</span></p>
</div>
<div class="proposition">
<p>עבור <span>\(P=\mathbb{1}\)</span> ו <span>\(Q=U\)</span> נקבל כי בפועל מחליף את ה-control ואת ה-target(למעשה <span>\(Q\)</span> יהיה אופרטור זהה במערכת <span>\(A\)</span>).</p>
</div>
<div class="corollary">
<p>אם האופרטור <span>\(U\)</span> אלכסוני בבסיס החישובי ניתן להחליף את ה-control ואת ה-target.</p>
</div>
    </div>
    <ul class='top-navigation'>
<li class='next-page'><a href='./Quantum_computation_5_2.html'>5.2 מעגלים קוונטים</a></li>
<li class='prev-page'><a href='./Quantum_computation_4_3.html'>4.3 מעגלים הפיכים</a></li>
</ul></li>
        </body>
        </html>
        