
<!DOCTYPE html>
<html data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles/main_style.css">
    <script type="text/javascript" src="./scripts/dark_mode.js"></script>

        <link rel="stylesheet" href='./styles/style.css'>
        <script>
window.MathJax = {
  tex: {
    inlineMath: [["$", "$"], ["\\(", "\\)"]],
    displayMath: [["$$", "$$"], ["\[", "\]"]],
    processEscapes: true,
    packages: ['base', 'ams', 'cancel', 'braket', 'mathtools', 'boldsymbol']
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process',
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }

  },
  loader: {
    load: ['[tex]/cancel', '[tex]/braket', '[tex]/mathtools', '[tex]/boldsymbol']
  }
};
window.onload = () => {
    const urlParams = new URLSearchParams(window.location.search);
    // Get the value of the 'item' parameter
    const item = urlParams.get('item'); 
    keywords = document.getElementsByClassName("keyword"); 
    for(let i = 0; i< keywords.length; i++){
    if(item==keywords[i].innerText){
    keywords[i].scrollIntoView();}} 

    const divs = document.querySelectorAll('div.content > div'); //:has(span):has(p)
    console.log(divs);
    divs.forEach(div => {
        div.addEventListener('mouseup', (event) => {
            // Check if it's middle button (button 1)
            console.log(div);
            if (event.button === 1) {
                console.log('Middle click detected');
                            // Get both paragraphs and lists
            const paragraphs = div.getElementsByTagName('p');
            const lists = div.querySelectorAll('ul, ol'); // Get both unordered and ordered lists
            
            console.log(paragraphs);
            console.log(lists);
            
            // Toggle each paragraph's visibility
            Array.from(paragraphs).forEach(paragraph => {
                if (paragraph.classList.contains('paragraph-hidden')) {
                    // Show paragraph
                    paragraph.classList.remove('paragraph-hidden');
                    // Update max-height to match content
                    paragraph.style.maxHeight = paragraph.scrollHeight + 'px';
                    console.log('Showing paragraph');
                } else {
                    // Hide paragraph
                    paragraph.classList.add('paragraph-hidden');
                    console.log('Hiding paragraph');
                }
            });
            
            // Toggle each list's visibility
            Array.from(lists).forEach(list => {
                if (list.classList.contains('paragraph-hidden')) {
                    // Show list (using the same class for consistency)
                    list.classList.remove('paragraph-hidden');
                    // Update max-height to match content
                    list.style.maxHeight = list.scrollHeight + 'px';
                    console.log('Showing list');
                } else {
                    // Hide list
                    list.classList.add('paragraph-hidden');
                    console.log('Hiding list');
                }
            });
                // Prevent default middle-click behavior
                event.preventDefault();
                return false;
            }
        });

        // Prevent the default middle-click scrolling behavior
        div.addEventListener('mousedown', (event) => {
            if (event.button === 1) {
                event.preventDefault();
                return false;
            }
        });
    });

};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"></script>    <script type='text/javascript' src='./scripts/main_script.js'></script>
            <title>שזירה</title>
        </head>
        <body>
        <ul class='top-navigation'>
<li class='next-page'><a href='./Quantum Computation_2_1'>2.1 מדידה אורתוגונאלית</a></li>
<li class='parent-page'><a href='./Quantum Computation'> חישוב קוונטי</a><ul class='parent-dropdown'>
<li class='parent-page-dropdown'><div class='dropdown-div'>1. יסודות</div><ul class='parent-dropdown-dropdown'>
<li class='parent-page-dropdown'><a href='./Quantum Computation_1_1'>1.1 עקרונות הפיזיקה הקוונטית</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_1_2'>1.2 ספינים וסיבובים</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_1_3'>1.3 מטריצת צפיפות וצברים</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_1_4'>1.4 שזירה</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>2. מערכות פתוחות</div><ul class='parent-dropdown-dropdown'>
<li class='parent-page-dropdown'><a href='./Quantum Computation_2_1'>2.1 מדידה אורתוגונאלית</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_2_2'>2.2 מדידה מוכללת</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_2_3'>2.3 ערוצים קוונטים</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_2_4'>2.4 שלושה ערוצי קיוביט</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_2_5'>2.5 משוואת המאסטר</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>3. שזירה</div><ul class='parent-dropdown-dropdown'>
<li class='parent-page-dropdown'><a href='./Quantum Computation_3_1'>3.1 מצבי בל</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_3_2'>3.2 שימושים של שזירה</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>4. מעגלים קלאסיים</div><ul class='parent-dropdown-dropdown'>
<li class='parent-page-dropdown'><a href='./Quantum Computation_4_1'>4.1 חישוב</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_4_2'>4.2 מחלקות סיבוכיות</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_4_3'>4.3 מעגלים הפיכים</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>5. מעגלים קוונטים</div><ul class='parent-dropdown-dropdown'>
<li class='parent-page-dropdown'><a href='./Quantum Computation_5_1'>5.1 שערים קוונטים</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_5_2'>5.2 מעגלים קוונטים</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_5_3'>5.3 אוניברסליות של מעגלים קוונטים</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_5_4'>5.4 קבצות שערים אוניברסליים</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>6. מימוש פיזי של מחשב קוונטי</div><ul class='parent-dropdown-dropdown'>
<li class='parent-page-dropdown'><a href='./Quantum Computation_6_1'>6.1 מלכודת פאול - קלאסי</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_6_2'>6.2 מלכודת פאול - קוונטי</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>7. אלגוריתמים קוונטים</div><ul class='parent-dropdown-dropdown'>
<li class='parent-page-dropdown'><a href='./Quantum Computation_7_1'>7.1 בעיות קבועה-מאוזנת</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_7_2'>7.2 מחזוריות</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_7_3'>7.3 התמרת פורייה קוונטית</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_7_4'>7.4 חיפוש</a></li>
</ul></li>
<li class='parent-page-dropdown'><div class='dropdown-div'>8. סימולציה קוונטית והצפנה</div><ul class='parent-dropdown-dropdown'>
<li class='parent-page-dropdown'><a href='./Quantum Computation_8_1'>8.1 טרוטריזציה</a></li>
<li class='parent-page-dropdown'><a href='./Quantum Computation_8_2'>8.2 תיקון שגיאות - קוד שור</a></li>
</ul></li>
</ul></li>
<li class='prev-page'><a href='./Quantum Computation_1_3'>1.3 מטריצת צפיפות וצברים</a></li>
</ul></li><script>document.addEventListener('keydown', function(event){if (event.key === 'ArrowRight') { window.location.href = `./Quantum Computation_2_1`; }if (event.key === 'ArrowLeft') { window.location.href = `./Quantum Computation_1_3`; }});</script>
        <div class="content">
        <h1>1.4  שזירה</h1>
    <div class="definition"><span class="keyword">מערכת שתי מערכות - Bipartite Hilbert Space</span><p>מרחב מכפלה של שתי מצבים:
<span>$$\mathcal{H}=\mathcal{H}_{A}\times \mathcal{H}_{B}$$</span>
עם בסיס אורתונורמלי <span>\(\{ \ket{ij} \}\)</span>. המצב הטהור הכללי ב-<span>\(\mathcal{H}\)</span> יהיה:
<span>$$\ket{\psi} = \sum_{ij} \psi_{ij} \ket{i} _{A}\ket{j} _{B}$$</span>
כאשר נסמן ב-<span>\(\psi_{ij}\)</span> את המטריצת אמפליטודות <span>\(d_{A}\times d_{B}\)</span>.</p>
</div>
<div class="definition"><span class="keyword">פירוק ערכים סינגולאריים <span>\(SVD\)</span></span><p>עבור מטריצה <span>\(\psi_{ij}\)</span> מגודל <span>\(d_{A}\times d_{B}\)</span> קיימת מטריצה אינוטרית <span>\(U_{A}\)</span> מגודל <span>\(d_{A}\times d_{A}\)</span> כאשר <span>\(U_{B}\)</span> היא מגודל <span>\(d_{B}\times d_{B}\)</span> ומטריצה מלבנית <span>\(\Lambda\left( d_{A}\times d_{B} \right)\)</span> כך ש:
<span>$$\psi=U_{A}^{T}\Lambda U_{B}$$</span>
כאשר נניח בלי הגבלת הכלליות כי <span>\(d_{A}\geq d_{B}\equiv d\)</span>. כאשר מטריצת הערכים הסינגולרית <span>\(\Lambda\)</span> תהיה מהצורה:
<span>$$\Lambda=\left(\begin{array}{c c c c}{{\lambda_{1}}}&amp;{{0}}&amp;{{\cdots}}&amp;{{0}}\\ {{0}}&amp;{{\ddots}}&amp;&amp;{{\vdots}}\\ {{\vdots}}&amp;{{}}&amp;{{\ddots}}&amp;{{0}}\\ {{0}}&amp;{{\cdots}}&amp;{{0}}&amp;{{\lambda_{d}}}\\ {{0}}&amp;{{\cdots}}&amp;{{\cdots}}&amp;{{0}}\\ {{\vdots}}&amp;{{}}&amp;{{}}&amp;{{\vdots}}\\ {{0}}&amp;{{\cdots}}&amp;{{\cdots}}&amp;{{0}}\end{array}\right)$$</span></p>
</div>
<div class="proposition">
<p>לכל מטריצה קיים פירוק ערכים סינוגלארים.</p>
</div>
<div class="proposition">
<p>בעזרת פירוק ערכים סינגולאריים ניתן לכתוב
<span>$$\left|\psi\right\rangle=\sum_{i j}\sum_{\mu}\left(U_{A}^{T}\right)_{i\mu}\lambda_{\mu}\left(U_{B}\right)_{\mu j}\left|i\right\rangle_{A}\otimes\left|j\right\rangle_{B}\equiv\sum_{\mu}\lambda_{\mu}\left|\mu\right\rangle_{A}\otimes\left|\mu\right\rangle_{B}$$</span>
כאשר הגדרנו בסיס אורתונורמלי חדש(מטריצת מעבר בסיס אוניטרית מעבירה בסיס אוניטרי לבסיס אוניטרי) בצורה הבאה:
<span>$$|\mu\rangle_{A}=\sum_{i}\left(U_{A}\right)_{\mu i}|i\rangle_{A}\quad,|\mu\rangle_{B}=\sum_{j}\left(U_{B}\right)_{\mu j}|j\rangle_{B}$$</span></p>
</div>
<div class="definition"><span class="keyword">צורת שמידט</span><p><span>$$|\psi\rangle=\sum_{\mu=1}^{d}\lambda_{\mu}\,|\mu\rangle_{A}\otimes|\mu\rangle_{B}$$</span>
כאשר <span>\(\lambda_{\mu}\)</span> נקרא מקדמי שמידט.</p>
</div>
<div class="proposition">
<p>כיוון שכל המקדמי שמידט הם חיוביים וממשיים ניתן לסדר אותם:
<span>$$\lambda_{1}\geq \lambda_{2} \geq \dots \geq \lambda_{d}$$</span>
כאשר דרישת הנירמול נותנת
<span>$$\sum_{\mu=1}^{d} \lambda_{\mu}^{2}=1$$</span></p>
</div>
<div class="definition"><span class="keyword">דרגת שמידט</span><p>מספר המקדמי שמידט שאינו אפס.</p>
</div>
<div class="remark">
<p>הדרגת שמידט המינימלית תהיה 1. זאת נובע מדרישת הנירמול.</p>
</div>
<div class="proposition"><span class="keyword">דרגת שמידט 1</span><p>עבור דרגת שמידט 1 נקבל
<span>$$\ket{\psi} = \ket{\mu=1}_{A} \otimes \ket{\mu=1}_{B}$$</span>
ונקבל כי אין קשר בין התתי מערכות.</p>
</div>
<div class="proposition"><span class="keyword">דרגת שמידט גדולה מ-1</span><p>עבור דרגת שמידט גדולה מ-1 נקבל כי <span>\(\ket{\psi}\)</span> היא שזורה.
<span>$$\ket{\psi} =\sum_{\mu=1} \lambda_{\mu} \ket{\mu}_{A}\otimes \ket{\mu}_{B}   $$</span>
כאשר מדידה של <span>\(\ket{\mu}_{A}\)</span> ב-<span>\(A\)</span> גורמת ל-<span>\(\ket{\mu}_{B}\)</span> מיידית.</p>
</div>
<h2>אנטרופיה שזירה</h2>
<div class="proposition">
<p><span>$$\rho_{A}=\mathrm{Tr_{B}}\left[\rho\right]=\sum_{\mu=1}^{d}\lambda_{\mu}^{2}\left|\mu\right\rangle_{A}\left\langle\mu\right|_{A}=\sum_{\mu=1}^{d}p_{\mu}\left|\mu\right\rangle_{A}\left\langle\mu\right|_{A}$$</span>
- אם יש שזירה, אנחנו עושים טרייס אוט לאחד המרחבים אז המצב שנשאר יהיה מצב מעורב.
- ניתן להתייחס לזה כעת כמו צבר קלאסי, עם צפיפות הסתברות קלאסי, ולכן ניתן להגדיר את האטרופיה כדי לכמת את האי וודאות של המצב <span>\(A\)</span>.</p>
</div>
<div class="definition"><span class="keyword">אנטרופיה פון נוימן</span><p>מוגדר על ידי
<span>$$S=-\sum_{\mu}p_{\mu}\ln p_{\mu}$$</span></p>
</div>
<div class="remark">
<p>כיוון ש<span>\(S\)</span> הוא צירוף קמור נקבל <span>\(S\geq 0\)</span>.</p>
</div>
<div class="proposition">
<p>כאשר אין שזירה נקבל כי האנטרופיה אפס כאשר באופן כללי נקבל.
<span>$$S_{A}=-\mathrm{Tr}\left[\rho_{A}\ln\rho_{A}\right]$$</span></p>
</div>
<div class="proposition"><span class="keyword">אנטרפיה מקסימלית</span><p>האנטרופיה מקסימלית כאשר <span>\(\rho_{A}\)</span> הוא אקראי לחלוטין. כלומר
<span>$$p_{\mu}=\frac{1}{d}\quad\forall\mu$$</span>
וכעת:
<span>$$S_{\mathrm{max}}=-\sum_{\mu=1}^{d}{\frac{1}{d}}\ln{\frac{1}{d}}=\ln d$$</span>
כאשר המטריצת הצפיפות במקרה זה תהיה:
<span>$$\rho=\frac{1}{d}\sum_{\mu}\left|\mu\right\rangle\left\langle\mu\right|=\frac{1}{d}\mathbb{1}$$</span></p>
</div>
<div class="example">
<p>נתון <span>\(A\)</span> מערכת 2 רמות ו-<span>\(B\)</span> מערכת 3 רמות. המערכת <span>\(A\)</span> ו-<span>\(B\)</span> שזורות באיזושהי דרך. המערכת הAB היא במצב טהור <span>\(\ket{\psi}\)</span>. כלומר ניתן לכתוב איבר במערכת בצורה כללית:
<span>$$\ket{\psi} =\sum_{ij}\psi_{ij}\ket{i} _{A}\otimes \ket{j} _{B}$$</span>
כאשר בצורת שמידט נקבל:
<span>$$\ket{\psi} = \sum_{\mu}\lambda_{\mu}\ket{\mu} _{A}\otimes \ket{\mu} _{B}$$</span>
המספר המקסימלי של מקדמי שמידט יהיה:
<span>$$\min \left( \dim A,\dim B \right)=2$$</span>
כאשר במצב האנטרופיית שזירה המקסימלית תתקבל כאשר שתינן שווים, כלומר נדרש <span>\(\lambda_{1}=\lambda_{2}=\frac{1}{2}\)</span>. לכן:
<span>$$S_{\max }=-\sum_{i}\lambda_{i}\ln \lambda_{i}= -2\cdot\frac{1}{2}\ln \frac{1}{2}=\ln 2$$</span></p>
</div>
<div class="proposition">
<p>תהי <span>\(\rho\)</span> מטריצת צפיפות הפועלת על שתי מערכות <span>\(A,B\)</span>. אופרטור אוניטרי הפועל רק על <span>\(B\)</span> לא תשנה את המטריצה המצומצמת <span>\(\rho _A\)</span>.</p>
</div>
<div class="proof">
<p>נתון לנו המצב <span>\(\rho\)</span>. נשים לב כי עבור מצב זה:
<span>$$\rho_{A}=\mathrm{Tr}\left( \rho \right)$$</span>
אם נבצע טרנספורמציה אוניטרית <span>\(U_{B}\)</span> הפועלת על תת מערכת <span>\(B\)</span> המצב <span>\(\rho\)</span> ישתנה למצב:
<span>$$ ρ' = (I_A ⊗ U_B) ρ (I_A ⊗ U_B)^† $$</span>
כאשר כעת:
<span>$$ρ'_A = \text{Tr}_B[(I_A ⊗ U_B) ρ (I_A ⊗ U_B)^†] \\= \text{Tr}_B[(I_A ⊗ U_B) ρ (I_A ⊗ U_B^†)] \\= \text{Tr}_B[U_B ρ U_B^†]  = \mathrm{Tr}_{B}\left( \rho \right)
$$</span></p>
</div>
<div class="corollary">
<p>אנטרופיית השזירה גם כן לא תשתנה</p>
</div>
<div class="proof">
<p>נזכור כי אנטרופיית השזירה נתונה על ידי:
<span>$$S=-\mathrm{Tr}\left[\rho_{A}\ln\rho_{A}\right]$$</span>
ולכן כיוון ש-<span>\(\rho_{A}\)</span> אינווריאנטית גם <span>\(S\)</span> אינווריאנטית.</p>
</div>
<div class="corollary">
<p>אם ניתן לכתוב אופרטור אוניטרי בצורה <span>\(U=U_{A}\otimes U_{B}\)</span> נקבל כי אנטרופיית השזירה לא תשתנה</p>
</div>
<div class="proof">
<p>אפשר לכתוב:
<span>$$U_{A}\otimes U_{B}=U_{A}\otimes \mathbb{1} _{B}+\mathbb{1} _{A}\otimes U_{B}$$</span>
וכעת מלינאריות העקבה האנטרופיית שזירה תהיה שווה לסכום של האנטרופיות שזירה של כל אחד מהמצבים האלה - אשר אינם משתנים תחת הטרנספורמציה. פיזיקלית אם פועלים עם כל מערכת בנפרד נצפה כי השזירה של המערכת לא תשתנה, אבל אם פועל על שתיהם ביחד השזירה יכולה להשתנות ואף להפוך את המערכת למצב מכפלה. </p>
</div>
<div class="example">
<p>נראה זאת בעזרת פירוק שמידט על מצב טהור:
ניתן לכתוב כל מצב טהור של שתי חלקיקים בעזרת פירוק שמידט בצורה הבאה:
<span>$$ |ψ⟩ = \sum_μ \sqrt{λ_μ} |μ⟩_A ⊗ |μ⟩_B $$</span>
כאשר <span>\(|μ⟩_A\)</span> ו-<span>\(|μ⟩_B\)</span> הם בסיסים אורתונורמליים עבור תת-מערכות A ו-B, בהתאמה, ו-<span>\(λ_μ\)</span> הם מקדמי שמידט (מספרים ממשיים לא שליליים). בצורת שמידט ניתן לחשב את האנטרופיה של המערכת בצורה הבאה:
<span>$$ S = -\sum_μ λ_μ \ln λ_μ $$</span>
כאשר נפעיל את האופרטור <span>\(U_{A}\otimes U_{B}\)</span> נקבל את המצב:
<span>$$ U|ψ⟩ = \sum_μ \sqrt{λ_μ} (U_A|μ⟩_A) ⊗ (U_B|μ⟩_B) $$</span>
ניתן כעת להגדיר בסיס אורתונורמלי חדש:
<span>$$ |\tilde{μ}⟩_A = U_A|μ⟩_A \qquad  |\tilde{μ}⟩_B = U_B|μ⟩_B $$</span>
כאשר שזה אכן יהיה בסיס אורתונורמלי בגלל התכונה של מטריצות אוניטריות - בעבירה בסיס אורתונורמלי לבסיס אורתונורמלי. לכן במצב חדש נקבל:
<span>$$ U|ψ⟩ = \sum_μ \sqrt{λ_μ} |\tilde{μ}⟩_A ⊗ |\tilde{μ}⟩_B $$</span>
ומקדמי השמידט לא משתנים! ולכן האנטרופיית שזירה לא משתנה.</p>
</div>
    </div>
    <ul class='top-navigation'>
<li class='next-page'><a href='./Quantum Computation_2_1'>2.1 מדידה אורתוגונאלית</a></li>
<li class='prev-page'><a href='./Quantum Computation_1_3'>1.3 מטריצת צפיפות וצברים</a></li>
</ul></li>
        </body>
        </html>
        